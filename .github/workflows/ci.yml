name: ci.jig.nvim

on:
  pull_request:
  push:
    branches:
      - main

jobs:
  required:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        nvim: [stable, v0.11.2]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y ripgrep

      - name: Setup Lua
        uses: leafo/gh-actions-lua@v11
        with:
          luaVersion: "5.4"

      - name: Setup LuaRocks
        uses: leafo/gh-actions-luarocks@v5

      - name: Install luacheck
        run: luarocks install luacheck

      - name: Install stylua
        uses: taiki-e/install-action@v2
        with:
          tool: stylua

      - name: Install Neovim
        uses: rhysd/action-setup-vim@v1
        with:
          neovim: true
          version: ${{ matrix.nvim }}

      - name: Legacy-brand guard
        run: |
          pattern='(nvim[-_]workbench|nvim(workbench)|nvim[-]2026|nvim(2026)|[N]vimWorkbench|[D]istroHealth|:[D]istro|distro[-]safe|distro[.])'
          if rg -n "$pattern" . ; then
            echo "legacy brand strings detected"
            exit 1
          fi

      - name: Hidden Unicode gate
        run: tests/check_hidden_unicode.sh

      - name: Naming checks
        run: |
          set -euo pipefail
          while IFS= read -r file; do
            base="$(basename "$file")"
            if [[ ! "$base" =~ ^[a-z0-9_]+\.lua$ ]]; then
              echo "invalid lua filename: $file"
              exit 1
            fi
          done < <(rg --files lua -g '*.lua')

          while IFS= read -r hit; do
            line="${hit#*:*:}"
            name="$(echo "$line" | sed -nE "s/.*nvim_create_user_command[[:space:]]*\([[:space:]]*['\"]([^'\"]+)['\"].*/\1/p")"
            if [[ -n "$name" && ! "$name" =~ ^Jig[A-Za-z0-9]*$ ]]; then
              echo "invalid command prefix: $hit"
              exit 1
            fi
          done < <(rg -n "nvim_create_user_command[[:space:]]*\(" lua || true)

          while IFS= read -r hit; do
            line="${hit#*:*:}"
            name="$(echo "$line" | sed -nE "s/.*nvim_create_augroup[[:space:]]*\([[:space:]]*['\"]([^'\"]+)['\"].*/\1/p")"
            if [[ -n "$name" && ! "$name" =~ ^Jig[A-Za-z0-9]*$ ]]; then
              echo "invalid augroup prefix: $hit"
              exit 1
            fi
          done < <(rg -n "nvim_create_augroup[[:space:]]*\(" lua || true)

      - name: Boundary checks
        run: |
          set -euo pipefail
          mapfile -t core_files < <(rg --files lua -g '*.lua' | rg '/core/.*\.lua$' || true)
          for file in "${core_files[@]}"; do
            if rg -n "require[[:space:]]*\(?[[:space:]]*['\"][^'\"]*([./]ui[./]|[./]agent[./]|\.ui\.|\.agent\.)" "$file"; then
              echo "forbidden core import: $file"
              exit 1
            fi
            if rg -n "vim\.api\." "$file" >/dev/null 2>&1; then
              if ! rg -n "boundary:[[:space:]]*allow-vim-api" "$file" >/dev/null 2>&1; then
                echo "missing boundary whitelist marker: $file"
                exit 1
              fi
            fi
          done

      - name: Platform conditional centralization gate
        run: |
          set -euo pipefail
          hits="$(rg -n 'vim\\.uv\\.os_uname|WSL_DISTRO_NAME|WSL_INTEROP|/proc/version' lua/jig | rg -v '^lua/jig/platform/' | rg -v '^lua/jig/tests/' || true)"
          if [[ -n "$hits" ]]; then
            echo "os detection must route through lua/jig/platform/*"
            echo "$hits"
            exit 1
          fi

      - name: Commit message checks
        if: github.event_name == 'pull_request'
        run: |
          set -euo pipefail
          range="${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }}"
          pattern='^(feat|fix|refactor|perf|docs|test|ci|build|chore|revert)(\([a-z0-9._/-]+\))?(!)?: .+'
          while IFS=$'\t' read -r hash subject; do
            [[ -z "$hash" ]] && continue
            [[ "$subject" =~ ^Merge\  ]] && continue
            if [[ ! "$subject" =~ $pattern ]]; then
              echo "invalid commit subject: $hash $subject"
              exit 1
            fi
          done < <(git log --no-merges --format='%H%x09%s' "$range")

      - name: Contract registry checks
        run: |
          lua -e 'package.path="./lua/?.lua;./lua/?/init.lua;"..package.path; assert(require("jig.spec.requirements").self_check())'
          rg -n "MUST|SHOULD|MAY" docs/contract.jig.nvim.md

      - name: Formatting check
        run: stylua --check --config-path .stylua.toml $(rg --files lua -g '*.lua')

      - name: Lint check
        run: luacheck --config .luacheckrc $(rg --files lua -g '*.lua')

      - name: Smoke test startup
        run: |
          nvim --headless -u ./init.lua '+lua print("jig-smoke")' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.g.jig_profile=="default")' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigHealth")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigVerboseMap")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigVerboseSet")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigBisectGuide")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigKeys")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigFiles")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigBuffers")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigRecent")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigSymbols")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigDiagnostics")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigHistory")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigGitChanges")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigLspHealth")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigLspInfo")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigLspSnapshot")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigExec")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigToolHealth")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigTerm")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigToolchainInstall")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigToolchainUpdate")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigToolchainRestore")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigToolchainRollback")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigMcpTrust")==0)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigMcpList")==0)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigAgentContext")==0)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(package.loaded["jig.agent"]==nil)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigRootSet")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigRootReset")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigPluginInstall")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigPluginUpdate")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigPluginRestore")==2)' '+qa'
          nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigPluginRollback")==2)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.g.jig_profile=="safe")' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(package.loaded["jig.ui"]==nil)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(package.loaded["jig.nav"]==nil)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(package.loaded["jig.lsp"]==nil)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(package.loaded["jig.tools"]==nil)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigFiles")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigLspHealth")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigLspInfo")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigLspSnapshot")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigExec")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigToolHealth")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigTerm")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigToolchainInstall")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigToolchainUpdate")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigToolchainRestore")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigToolchainRollback")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigMcpTrust")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigMcpList")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(vim.fn.exists(":JigAgentContext")==0)' '+qa'
          NVIM_APPNAME=jig-safe nvim --headless -u ./init.lua '+lua assert(package.loaded["jig.agent"]==nil)' '+qa'

      - name: Scorecard harness snapshot checks
        run: |
          tests/scorecard/run_harness.sh
          test -f tests/scorecard/snapshots/latest-headless.json
          rg -n '"wp15-research-done-gate"' tests/scorecard/snapshots/latest-headless.json
          rg -n '"wp15-gaps-gate"' tests/scorecard/snapshots/latest-headless.json
          rg -n '"wp15-generate-scorecard"' tests/scorecard/snapshots/latest-headless.json
          rg -n '"wp15-generate-dashboard"' tests/scorecard/snapshots/latest-headless.json
          rg -n '"wp15-generated-sync-clean"' tests/scorecard/snapshots/latest-headless.json

      - name: Cmdline open-close check
        run: nvim --headless -u ./init.lua '+JigCmdlineCheck' '+qa'

      - name: UI harness snapshot checks
        run: |
          tests/ui/run_harness.sh
          test -f tests/ui/snapshots/latest-headless.json
          rg -n '"timing-sensitive"' tests/ui/snapshots/latest-headless.json
          rg -n '"ascii-fallback-legibility"' tests/ui/snapshots/latest-headless.json

      - name: Navigation harness snapshot checks
        run: |
          tests/nav/run_harness.sh
          test -f tests/nav/snapshots/latest-headless.json
          rg -n '"root-determinism"' tests/nav/snapshots/latest-headless.json
          rg -n '"latency-budget-smoke"' tests/nav/snapshots/latest-headless.json
          rg -n '"candidate-cap-guardrail"' tests/nav/snapshots/latest-headless.json
          rg -n '"large-fixture-tier-guardrail"' tests/nav/snapshots/latest-headless.json

      - name: Keymap harness snapshot checks
        run: |
          tests/keymaps/run_harness.sh
          test -f tests/keymaps/snapshots/latest-headless.json
          rg -n '"forbidden-defaults"' tests/keymaps/snapshots/latest-headless.json
          rg -n '"runtime-forbidden-not-mapped"' tests/keymaps/snapshots/latest-headless.json
          rg -n '"runtime-registry-subset"' tests/keymaps/snapshots/latest-headless.json
          rg -n '"docs-sync-gate"' tests/keymaps/snapshots/latest-headless.json

      - name: Completion harness snapshot checks
        run: |
          tests/completion/run_harness.sh
          test -f tests/completion/snapshots/latest-headless.json
          rg -n '"completion-policy-defaults"' tests/completion/snapshots/latest-headless.json
          rg -n '"completion-fallback-smoke"' tests/completion/snapshots/latest-headless.json

      - name: Keymap docs sync gate
        run: |
          nvim --headless -u ./init.lua '+lua package.path="./lua/?.lua;./lua/?/init.lua;"..package.path; _G.__jig_repo_root=vim.fn.getcwd(); require("jig.core.keymap_docs").generate({ check = true })' '+qa'

      - name: Generate and verify helptags
        run: |
          nvim --headless -u NONE -l tests/docs/update_helptags.lua
          git diff --exit-code -- doc/tags

      - name: Docs harness snapshot checks
        run: |
          tests/docs/run_harness.sh
          test -f tests/docs/snapshots/latest-headless.json
          rg -n '"required-vimdoc-set"' tests/docs/snapshots/latest-headless.json
          rg -n '"docs-index-command-open-close"' tests/docs/snapshots/latest-headless.json
          rg -n '"help-entrypoint"' tests/docs/snapshots/latest-headless.json
          rg -n '"repro-command-surface"' tests/docs/snapshots/latest-headless.json
          rg -n '"command-doc-sync-gate"' tests/docs/snapshots/latest-headless.json
          rg -n '"command-doc-cross-reference"' tests/docs/snapshots/latest-headless.json
          rg -n '"markdown-link-check"' tests/docs/snapshots/latest-headless.json
          rg -n '"help-reference-check"' tests/docs/snapshots/latest-headless.json
          rg -n '"issue-template-failure-surfaces"' tests/docs/snapshots/latest-headless.json
          rg -n '"labels-manifest-controls"' tests/docs/snapshots/latest-headless.json
          rg -n '"execution-board-wp16-wp17-tracking"' tests/docs/snapshots/latest-headless.json

      - name: LSP harness snapshot checks
        run: |
          tests/lsp/run_harness.sh
          test -f tests/lsp/snapshots/latest-headless.json
          rg -n '"default-command-surface"' tests/lsp/snapshots/latest-headless.json
          rg -n '"failure-isolation"' tests/lsp/snapshots/latest-headless.json
          rg -n '"safe-profile-isolation"' tests/lsp/snapshots/latest-headless.json

      - name: Tools harness snapshot checks
        run: |
          tests/tools/run_harness.sh
          test -f tests/tools/snapshots/latest-headless.json
          rg -n '"provider-health-tests"' tests/tools/snapshots/latest-headless.json
          rg -n '"command-execution-smoke"' tests/tools/snapshots/latest-headless.json
          rg -n '"capture-concurrency-guard"' tests/tools/snapshots/latest-headless.json
          rg -n '"timeout-or-nil-path"' tests/tools/snapshots/latest-headless.json
          rg -n '"toolchain-install-restore-version-equality"' tests/tools/snapshots/latest-headless.json
          rg -n '"toolchain-rollback-restores-previous-lock"' tests/tools/snapshots/latest-headless.json
          rg -n '"toolchain-drift-visible-in-health"' tests/tools/snapshots/latest-headless.json
          rg -n '"toolchain-drift-warning-via-jighealth"' tests/tools/snapshots/latest-headless.json
          rg -n '"safe-profile-isolation"' tests/tools/snapshots/latest-headless.json

      - name: Agent harness snapshot checks
        run: |
          tests/agent/run_harness.sh
          test -f tests/agent/snapshots/latest-headless.json
          rg -n '"default-profile-agent-disabled"' tests/agent/snapshots/latest-headless.json
          rg -n '"permission-policy-unit"' tests/agent/snapshots/latest-headless.json
          rg -n '"task-cancel-resume"' tests/agent/snapshots/latest-headless.json
          rg -n '"mcp-failure-injection"' tests/agent/snapshots/latest-headless.json
          rg -n '"acp-bridge-hook"' tests/agent/snapshots/latest-headless.json
          rg -n '"context-ledger-token-budget"' tests/agent/snapshots/latest-headless.json
          rg -n '"safe-profile-isolation"' tests/agent/snapshots/latest-headless.json

      - name: Security harness snapshot checks
        run: |
          tests/security/run_harness.sh
          test -f tests/security/snapshots/latest-headless.json
          rg -n '"startup-network-trace-clean"' tests/security/snapshots/latest-headless.json
          rg -n '"startup-network-trace-fixture"' tests/security/snapshots/latest-headless.json
          rg -n '"mcp-trust-enforcement"' tests/security/snapshots/latest-headless.json
          rg -n '"exec-safety-override-logging"' tests/security/snapshots/latest-headless.json
          rg -n '"safe-profile-isolation"' tests/security/snapshots/latest-headless.json

      - name: Ops harness snapshot checks
        run: |
          tests/ops/run_harness.sh
          test -f tests/ops/snapshots/latest-headless.json
          rg -n '"channel-persistence"' tests/ops/snapshots/latest-headless.json
          rg -n '"rollback-restore-without-lazy"' tests/ops/snapshots/latest-headless.json
          rg -n '"staged-break-rollback-drill"' tests/ops/snapshots/latest-headless.json

      - name: Platform harness snapshot checks
        run: |
          nvim --headless -u NONE -l tests/run_harness.lua -- --suite platform
          test -f tests/platform/snapshots/latest-headless.json
          rg -n '"os-and-stdpath-invariants"' tests/platform/snapshots/latest-headless.json
          rg -n '"path-join-normalize-roundtrip"' tests/platform/snapshots/latest-headless.json
          rg -n '"shell-detection-and-argv-strategy"' tests/platform/snapshots/latest-headless.json
          rg -n '"clipboard-non-fatal"' tests/platform/snapshots/latest-headless.json
          rg -n '"root-detection-normalized-input"' tests/platform/snapshots/latest-headless.json

      - name: Pending harness snapshot checks
        run: |
          tests/pending/run_harness.sh
          test -f tests/pending/snapshots/latest-headless.json
          rg -n '"agent:approval-notification-visible"' tests/pending/snapshots/latest-headless.json
          rg -n '"agent:patch-diff-hunk-apply"' tests/pending/snapshots/latest-headless.json
          rg -n '"status":"pending"' tests/pending/snapshots/latest-headless.json

      - name: Quarantine and pending allowlist gates
        run: |
          nvim --headless -u NONE -l tests/check_quarantine.lua
          nvim --headless -u NONE -l tests/check_pending.lua

      - name: Quarantine growth policy (PR only)
        if: github.event_name == 'pull_request'
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          tests/check_quarantine_growth.sh "${{ github.event.pull_request.base.sha }}" "${{ github.event.pull_request.head.sha }}"

      - name: Performance harness snapshot checks
        run: |
          tests/perf/run_harness.sh
          test -f tests/perf/snapshots/latest-headless.json
          rg -n '"time-to-first-diagnostic"' tests/perf/snapshots/latest-headless.json
          rg -n '"time-to-first-completion-menu"' tests/perf/snapshots/latest-headless.json
          rg -n '"time-to-first-picker-results"' tests/perf/snapshots/latest-headless.json
          rg -n '"metrics"' tests/perf/snapshots/latest-headless.json

      - name: Upload perf snapshot artifact
        uses: actions/upload-artifact@v4
        with:
          name: perf-snapshot-${{ matrix.nvim }}
          path: tests/perf/snapshots/latest-headless.json

      - name: Cross-platform runner smoke
        run: |
          nvim --headless -u NONE -l tests/run_harness.lua -- --suite startup --suite cmdline --suite keymaps --suite nav --suite tools --suite security --suite platform

      - name: Deprecated API gate
        run: tests/lsp/check_deprecated.sh

      - name: Startup side-effect policy
        run: |
          set -euo pipefail
          tmp="$(mktemp -d)"
          XDG_DATA_HOME="$tmp/data" \
          XDG_CONFIG_HOME="$tmp/config" \
          XDG_STATE_HOME="$tmp/state" \
          XDG_CACHE_HOME="$tmp/cache" \
          NVIM_APPNAME=jig-ci \
          nvim --headless -u ./init.lua '+qa'
          test ! -d "$tmp/data/jig-ci/lazy/lazy.nvim"
          test ! -f "$tmp/config/jig-ci/jig-toolchain-manifest.json"
          test ! -f "$tmp/config/jig-ci/jig-toolchain-lock.json"

      - name: Health check
        run: nvim --headless -u ./init.lua '+JigHealth' '+qa'

  compat-matrix:
    name: compat-matrix (${{ matrix.target }})
    runs-on: ${{ matrix.runs_on }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: linux-x64
            runs_on: ubuntu-latest
          - target: linux-arm64
            runs_on: ubuntu-24.04-arm
          - target: macos-arm64
            runs_on: macos-14
          - target: macos-intel
            runs_on: macos-15-intel
          - target: windows-x64
            runs_on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install ripgrep (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y ripgrep

      - name: Install ripgrep (macOS)
        if: runner.os == 'macOS'
        run: brew install ripgrep

      - name: Install ripgrep (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: choco install ripgrep -y

      - name: Install Neovim
        uses: rhysd/action-setup-vim@v1
        with:
          neovim: true
          version: stable

      - name: Cross-platform core workflow harness
        run: |
          nvim --headless -u NONE -l tests/run_harness.lua -- --suite startup --suite cmdline --suite keymaps --suite nav --suite tools --suite platform

  wsl-best-effort:
    runs-on: windows-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4

      - name: Install Neovim (Windows host)
        uses: rhysd/action-setup-vim@v1
        with:
          neovim: true
          version: stable

      - name: WSL probe and harness (best-effort)
        shell: pwsh
        run: |
          if (-not (Get-Command wsl -ErrorAction SilentlyContinue)) {
            Write-Host "WSL command unavailable on hosted runner; skipping."
            exit 0
          }
          wsl --status
          if ($LASTEXITCODE -ne 0) {
            Write-Host "WSL not configured on hosted runner; skipping."
            exit 0
          }

          $repoWin = (Get-Location).Path
          $repoWsl = wsl wslpath -a "$repoWin"
          if ($LASTEXITCODE -ne 0 -or [string]::IsNullOrWhiteSpace($repoWsl)) {
            Write-Host "Unable to map repo path into WSL; skipping."
            exit 0
          }

          wsl bash -lc "cd '$repoWsl' && if command -v nvim >/dev/null 2>&1; then nvim --headless -u NONE -l tests/run_harness.lua -- --suite startup --suite cmdline --suite keymaps --suite nav --suite tools --suite platform; else echo 'nvim missing in WSL distro; skipping.'; fi"

  nightly-report:
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y ripgrep

      - name: Install Neovim (nightly)
        uses: rhysd/action-setup-vim@v1
        with:
          neovim: true
          version: nightly

      - name: Smoke and health (nightly)
        run: |
          nvim --headless -u ./init.lua '+lua print("jig-smoke-nightly")' '+qa'
          nvim --headless -u ./init.lua '+checkhealth jig' '+qa'
